<html>
<head><meta name="generator" content="Hexo 3.8.0">
	
	<title>python</title>
	<meta name="keywords" content="">

    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css">
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    

</head>

<body>


<h2 class="title">python</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2019年1月8日




 </div>
--->



<p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-14647" target="_blank" rel="noopener">CVE-2018-14647</a><br>Python’s elementtree C accelerator failed to initialise Expat’s hash salt during initialization. This could make it easy to conduct denial of service attacks against Expat by constructing an XML document that would cause pathological hash collisions in Expat’s internal data structures, consuming large amounts CPU and RAM. Python 3.8, 3.7, 3.6, 3.5, 3.4, 2.7 are believed to be vulnerable.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-1000802" target="_blank" rel="noopener">CVE-2018-1000802</a><br>Python Software Foundation Python (CPython) version 2.7 contains a CWE-77: Improper Neutralization of Special Elements used in a Command (‘Command Injection’) vulnerability in shutil module (make_archive function) that can result in Denial of service, Information gain via injection of arbitrary files on the system or entire drive. This attack appear to be exploitable via Passage of unfiltered user input to the function. This vulnerability appears to have been fixed in after commit add531a1e55b0a739b0f42582f1c9747e5649ace.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-1061" target="_blank" rel="noopener">CVE-2018-1061</a><br>python before versions 2.7.15, 3.4.9, 3.5.6rc1, 3.6.5rc1 and 3.7.0 is vulnerable to catastrophic backtracking in the difflib.IS_LINE_JUNK method. An attacker could use this flaw to cause denial of service.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-1060" target="_blank" rel="noopener">CVE-2018-1060</a><br>python before versions 2.7.15, 3.4.9, 3.5.6rc1, 3.6.5rc1 and 3.7.0 is vulnerable to catastrophic backtracking in pop3lib’s apop() method. An attacker could use this flaw to cause denial of service.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-3539" target="_blank" rel="noopener">CVE-2014-3539</a><br>base/oi/doa.py in the Rope library in CPython (aka Python) allows remote attackers to execute arbitrary code by leveraging an unsafe call to pickle.load.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-1000117" target="_blank" rel="noopener">CVE-2018-1000117</a><br>Python Software Foundation CPython version From 3.2 until 3.6.4 on Windows contains a Buffer Overflow vulnerability in os.symlink() function on Windows that can result in Arbitrary code execution, likely escalation of privilege. This attack appears to be exploitable via a python script that creates a symlink with an attacker controlled name or location. This vulnerability appears to have been fixed in 3.7.0 and 3.6.5.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-18207" target="_blank" rel="noopener">CVE-2017-18207</a><br><strong> DISPUTED </strong> The Wave_read._read_fmt_chunk function in Lib/wave.py in Python through 3.6.4 does not ensure a nonzero channel value, which allows attackers to cause a denial of service (divide-by-zero and exception) via a crafted wav format audio file. NOTE: the vendor disputes this issue because Python applications “need to be prepared to handle a wide variety of exceptions.”<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-1000030" target="_blank" rel="noopener">CVE-2018-1000030</a><br>Python 2.7.14 is vulnerable to a Heap-Buffer-Overflow as well as a Heap-Use-After-Free. Python versions prior to 2.7.14 may also be vulnerable and it appears that Python 2.7.17 and prior may also be vulnerable however this has not been confirmed. The vulnerability lies when multiply threads are handling large amounts of data. In both cases there is essentially a race condition that occurs. For the Heap-Buffer-Overflow, Thread 2 is creating the size for a buffer, but Thread1 is already writing to the buffer without knowing how much to write. So when a large amount of data is being processed, it is very easy to cause memory corruption using a Heap-Buffer-Overflow. As for the Use-After-Free, Thread3-&gt;Malloc-&gt;Thread1-&gt;Free’s-&gt;Thread2-Re-uses-Free’d Memory. The PSRT has stated that this is not a security vulnerability due to the fact that the attacker must be able to run code, however in some situations, such as function as a service, this vulnerability can potentially be used by an attacker to violate a trust boundary, as such the DWF feels this issue deserves a CVE.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-17522" target="_blank" rel="noopener">CVE-2017-17522</a><br><strong> DISPUTED </strong> Lib/webbrowser.py in Python through 3.6.3 does not validate strings before launching the program specified by the BROWSER environment variable, which might allow remote attackers to conduct argument-injection attacks via a crafted URL. NOTE: a software maintainer indicates that exploitation is impossible because the code relies on subprocess.Popen and the default shell=False setting.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-1000158" target="_blank" rel="noopener">CVE-2017-1000158</a><br>CPython (aka Python) up to 2.7.13 is vulnerable to an integer overflow in the PyString_DecodeEscape function in stringobject.c, resulting in heap-based buffer overflow (and possible arbitrary code execution)<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-4616" target="_blank" rel="noopener">CVE-2014-4616</a><br>Array index error in the scanstring function in the _json module in Python 2.7 through 3.5 and simplejson before 2.6.1 allows context-dependent attackers to read arbitrary process memory via a negative index value in the idx argument to the raw_decode function.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-5699" target="_blank" rel="noopener">CVE-2016-5699</a><br>CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-5636" target="_blank" rel="noopener">CVE-2016-5636</a><br>Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0772" target="_blank" rel="noopener">CVE-2016-0772</a><br>The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a “StartTLS stripping attack.”<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-2183" target="_blank" rel="noopener">CVE-2016-2183</a><br>The DES and Triple DES ciphers, as used in the TLS, SSH, and IPSec protocols and other protocols and products, have a birthday bound of approximately four billion blocks, which makes it easier for remote attackers to obtain cleartext data via a birthday attack against a long-duration encrypted session, as demonstrated by an HTTPS session using Triple DES in CBC mode, aka a “Sweet32” attack.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-7440" target="_blank" rel="noopener">CVE-2013-7440</a><br>The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-1494" target="_blank" rel="noopener">CVE-2016-1494</a><br>The verify function in the RSA package for Python (Python-RSA) before 3.3 allows attackers to spoof signatures with a small public exponent via crafted signature padding, aka a BERserk attack.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-5652" target="_blank" rel="noopener">CVE-2015-5652</a><br>Untrusted search path vulnerability in python.exe in Python through 3.5.0 on Windows allows local users to gain privileges via a Trojan horse readline.pyd file in the current working directory. NOTE: the vendor says “It was determined that this is a longtime behavior of Python that cannot really be altered at this point.”<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-9365" target="_blank" rel="noopener">CVE-2014-9365</a><br>The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject’s (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-2667" target="_blank" rel="noopener">CVE-2014-2667</a><br>Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-7185" target="_blank" rel="noopener">CVE-2014-7185</a><br>Integer overflow in bufferobject.c in Python before 2.7.8 allows context-dependent attackers to obtain sensitive information from process memory via a large size and offset in a “buffer” function.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-7040" target="_blank" rel="noopener">CVE-2013-7040</a><br>Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table. NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-7338" target="_blank" rel="noopener">CVE-2013-7338</a><br>Python before 3.3.4 RC1 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via a file size value larger than the size of the zip file to the (1) ZipExtFile.read, (2) ZipExtFile.read(n), (3) ZipExtFile.readlines, (4) ZipFile.extract, or (5) ZipFile.extractall function.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-1912" target="_blank" rel="noopener">CVE-2014-1912</a><br>Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-2099" target="_blank" rel="noopener">CVE-2013-2099</a><br>Algorithmic complexity vulnerability in the ssl.match_hostname function in Python 3.2.x, 3.3.x, and earlier, and unspecified versions of python-backports-ssl_match_hostname as used for older Python versions, allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-4238" target="_blank" rel="noopener">CVE-2013-4238</a><br>The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a ‘\0’ character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-1150" target="_blank" rel="noopener">CVE-2012-1150</a><br>Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-0845" target="_blank" rel="noopener">CVE-2012-0845</a><br>SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-4944" target="_blank" rel="noopener">CVE-2011-4944</a><br>Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2135" target="_blank" rel="noopener">CVE-2012-2135</a><br>The utf-16 decoder in Python 3.1 through 3.3 does not update the aligned_end variable after calling the unicode_decode_call_errorhandler function, which allows remote attackers to obtain sensitive information (process memory) or cause a denial of service (memory corruption and crash) via unspecified vectors.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-4940" target="_blank" rel="noopener">CVE-2011-4940</a><br>The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-1521" target="_blank" rel="noopener">CVE-2011-1521</a><br>The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-1015" target="_blank" rel="noopener">CVE-2011-1015</a><br>The is_cgi method in CGIHTTPServer.py in the CGIHTTPServer module in Python 2.5, 2.6, and 3.0 allows remote attackers to read script source code via an HTTP GET request that lacks a / (slash) character at the beginning of the URI.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3493" target="_blank" rel="noopener">CVE-2010-3493</a><br>Multiple race conditions in smtpd.py in the smtpd module in Python 2.6, 2.7, 3.1, and 3.2 alpha allow remote attackers to cause a denial of service (daemon outage) by establishing and then immediately closing a TCP connection, leading to the accept function having an unexpected return value of None, an unexpected value of None for the address, or an ECONNABORTED, EAGAIN, or EWOULDBLOCK error, or the getpeername function having an ENOTCONN error, a related issue to CVE-2010-3492.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3492" target="_blank" rel="noopener">CVE-2010-3492</a><br>The asyncore module in Python before 3.2 does not properly handle unsuccessful calls to the accept function, and does not have accompanying documentation describing how daemon applications should handle unsuccessful calls to the accept function, which makes it easier for remote attackers to conduct denial of service attacks that terminate these applications via network connections.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2089" target="_blank" rel="noopener">CVE-2010-2089</a><br>The audioop module in Python 2.7 and 3.2 does not verify the relationships between size arguments and byte string lengths, which allows context-dependent attackers to cause a denial of service (memory corruption and application crash) via crafted arguments, as demonstrated by a call to audioop.reverse with a one-byte string, a different vulnerability than CVE-2010-1634.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1634" target="_blank" rel="noopener">CVE-2010-1634</a><br>Multiple integer overflows in audioop.c in the audioop module in Python 2.6, 2.7, 3.1, and 3.2 allow context-dependent attackers to cause a denial of service (application crash) via a large fragment, as demonstrated by a call to audioop.lin2lin with a long string in the first argument, leading to a buffer overflow. NOTE: this vulnerability exists because of an incorrect fix for CVE-2008-3143.5.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1450" target="_blank" rel="noopener">CVE-2010-1450</a><br>Multiple buffer overflows in the RLE decoder in the rgbimg module in Python 2.5 allow remote attackers to have an unspecified impact via an image file containing crafted data that triggers improper processing within the (1) longimagedata or (2) expandrow function.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1449" target="_blank" rel="noopener">CVE-2010-1449</a><br>Integer overflow in rgbimgmodule.c in the rgbimg module in Python 2.5 allows remote attackers to have an unspecified impact via a large image that triggers a buffer overflow. NOTE: this vulnerability exists because of an incomplete fix for CVE-2008-3143.12.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-4134" target="_blank" rel="noopener">CVE-2009-4134</a><br>Buffer underflow in the rgbimg module in Python 2.5 allows remote attackers to cause a denial of service (application crash) via a large ZSIZE value in a black-and-white (aka B/W) RGB image that triggers an invalid pointer dereference.<br><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5031" target="_blank" rel="noopener">CVE-2008-5031</a><br>Multiple integer overflows in Python 2.2.3 through 2.5.1, and 2.6, allow context-dependent attackers to have an unknown impact via a large integer value in the tabsize argument to the expandtabs method, as implemented by (1) the string_expandtabs function in Objects/stringobject.c and (2) the unicode_expandtabs function in Objects/unicodeobject.c. NOTE: this vulnerability reportedly exists because of an incomplete fix for CVE-2008-2315.</p>


<!--<a href="http://cve.justshuoz.com/about/python.html#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = ''; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=&web_id=" language="JavaScript"></script>script>
</div>






</body>
</html>